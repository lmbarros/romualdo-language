package main

import (
	"fmt"
	"strings"
	"time"
)

type GDScriptBackend struct {
	result      string
	indentLevel int
}

func (be *GDScriptBackend) Visit(node interface{}) {
	switch n := node.(type) {
	case *SourceFile:
		be.visitSourceFile(n)
	case *VarDecl:
		be.visitVarDecl(n)
	case *Passage:
		be.visitPassage(n)
	case *Assignment:
		be.visitAssignment(n)
	}
}

func (be *GDScriptBackend) Leave(node interface{}) {
	switch node.(type) {
	case *Vars:
		be.result += "\n"
	case *Passage:
		be.indentLevel--
	}
}

func (be *GDScriptBackend) visitSourceFile(_ *SourceFile) {
	be.result += "#\n" +
		fmt.Sprintf("# Generated by romulangc at %v\n", time.Now()) +
		"#\n\n" +
		"extends Node\n\n"
}

func (be *GDScriptBackend) visitPassage(p *Passage) {
	be.result += fmt.Sprintf("%vfunc %v() -> %v:\n",
		indentGDScript(be.indentLevel), *p.Name, *p.ReturnType)
	be.indentLevel++
}

func (be *GDScriptBackend) visitAssignment(a *Assignment) {
	be.result += fmt.Sprintf("%v%v = %v\n",
		indentGDScript(be.indentLevel), *a.Var, *a.Value)
}

func (be *GDScriptBackend) visitVarDecl(vd *VarDecl) {
	be.result += fmt.Sprintf("var %v: %v = %v\n", *vd.Name,
		toGDScriptType(*vd.Type), *vd.InitialValue)
}

// indentGDScript returns a string good for indenting GDScript code level levels deep.
func indentGDScript(level int) string {
	return strings.Repeat("\t", level)
}

func toGDScriptType(t string) string {
	if t == "string" {
		return "String"
	}

	return t
}
